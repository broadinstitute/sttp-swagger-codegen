{{>licenseInfo}}
package {{package}}

{{#imports}}import {{import}}
{{/imports}}

import sttp.client._
import sttp.model.Uri


import {{invokerPackage}}.Decoders._
import {{invokerPackage}}.Encoders._
import {{invokerPackage}}.Backends._
import {{invokerPackage}}.SttpUtils.Implicits._

import collection.mutable

{{#operations}}
class {{classname}}() {

  {{#operation}}
  /**
   * {{summary}}
   * {{notes}}
   *
{{#allParams}}   * @param {{paramName}} {{description}} {{^required}}(optional{{#defaultValue}}, default to {{{.}}}{{/defaultValue}}){{/required}}
{{/allParams}}   * @return {{#returnType}}{{{returnType}}}{{/returnType}}{{^returnType}}Option[Unit]{{/returnType}}
   */
  def {{operationId}}(
    {{#allParams}}{{^required}}{{paramName}}: Option[{{dataType}}] = {{#defaultValue}}Option({{#isString}}"{{{defaultValue}}}"{{/isString}}{{^isString}}{{#isByteArray}}"{{/isByteArray}}{{#isDate}}dateFormatter.parse("{{/isDate}}{{#isDateTime}}dateTimeFormatter.parse("{{/isDateTime}}{{{defaultValue}}}{{#isDate}}"){{/isDate}}{{#isDateTime}}"){{/isDateTime}}{{#isByteArray}}".getBytes{{/isByteArray}}{{/isString}}){{/defaultValue}}{{^defaultValue}}None{{/defaultValue}}{{#hasMore}},{{/hasMore}}
    {{/required}}{{#required}}{{paramName}}: {{dataType}}{{#defaultValue}} = {{#isString}}"{{{defaultValue}}}"{{/isString}}{{^isString}}{{#isByteArray}}"{{/isByteArray}}{{#isDate}}dateFormatter.parse("{{/isDate}}{{#isDateTime}}dateTimeFormatter.parse("{{/isDateTime}}{{{defaultValue}}}{{#isDate}}"){{/isDate}}{{#isDateTime}}"){{/isDateTime}}{{#isByteArray}}".getBytes{{/isByteArray}}{{/isString}}{{/defaultValue}}{{#hasMore}},
    {{/hasMore}}{{/required}}{{/allParams}})(implicit
    reader: ClientResponseReader[{{#returnType}}{{returnType}}{{/returnType}}{{^returnType}}Unit{{/returnType}}]{{#bodyParams}},
    writer: RequestWriter[{{^required}}Option[{{dataType}}]{{/required}}{{#required}}{{dataType}}{{/required}}]{{/bodyParams}}
  ){{#returnType}}: Option[{{returnType}}]{{/returnType}}{{^returnType}}: Option[Unit]{{/returnType}} = {
  // create path and map variables
    val path = "{{path}}"{{#pathParams}}
        .replaceAll("\\{" + "{{baseName}}" + "\\}", {{paramName}}.toString){{/pathParams}}

    // query params
    val queryParams = new mutable.HashMap[String, String]
    val headerParams = new mutable.HashMap[String, String]

  {{#allParams}}
      {{#required}}
          {{^isPrimitiveType}}
    assert({{paramName}} != null, "Missing required parameter '{{paramName}}' when calling {{classname}}->{{operationId}}")
          {{/isPrimitiveType}}
          {{#isString}}
    assert({{paramName}} != null, "Missing required parameter '{{paramName}}' when calling {{classname}}->{{operationId}}")
          {{/isString}}
      {{/required}}
  {{/allParams}}
  {{#queryParams}}
      {{^required}}
      {{paramName}} match {
        case Some(param) => queryParams += "{{baseName}}" -> param.toString
        case _ => queryParams
      }
      {{/required}}
      {{#required}}
      queryParams += "{{baseName}}" -> {{paramName}}.toString
      {{/required}}
  {{/queryParams}}
  {{#headerParams}}
      {{^required}}
      {{paramName}} match {
          case Some(param) => headerParams += "{{baseName}}" -> param.toString
          case _ => headerParams
      }
      {{/required}}
      {{#required}}
      headerParams += "{{baseName}}" -> {{paramName}}.toString
      {{/required}}
  {{/headerParams}}

    basicRequest
      .{{httpMethodLowerCase}}(uri"{{basePath}}{{{pathWithInterpolations}}}{{{query}}}")
  {{#headerParams}}
      {{^required}}
      .headerOpt({{basename}}, {{paramName}}.map(_.toString))
      {{/required}}
      {{#required}}
      .header({{baseName}}, {{paramName}}.toString)
      {{/required}}
  {{/headerParams}}

    val resOpt = client.submit("{{httpMethod}}", path, queryParams.toMap, headerParams.toMap, {{#bodyParam}}writer.write({{paramName}}){{/bodyParam}}{{^bodyParam}}"{{emptyBodyParam}}"{{/bodyParam}})
    resOpt.map(reader.read)
  }

  {{/operation}}
}

{{/operations}}
